package typegen

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

// Creates a new Generator
func NewGenerator(inputDir, outputDir string, opts *Options) *Generator {
	if opts == nil {
		opts = &Options{
			UseInterface:     false,
			UseReadonly:      false,
			OutputFileName:   "types.d.ts",
			NamingConvention: NamingConventionCamelCase,
		}
	}

	return &Generator{
		InputDir:  inputDir,
		OutputDir: outputDir,
		Options:   opts,
	}
}

// Generates the TypeScript type definitions
func (g *Generator) Generate() error {
	// Parse single file
	types, err := g.parseGoFiles()
	if err != nil {
		return fmt.Errorf("failed to parse go files: %w", err)
	}

	tsContent := g.generateTypeScript(types)

	// If output file name is not specified, generate from input file name
	if g.Options.OutputFileName == "" {
		base := filepath.Base(g.InputDir)
		g.Options.OutputFileName = strings.TrimSuffix(base, ".go") + ".ts"
	}

	outputPath := filepath.Join(g.OutputDir, g.Options.OutputFileName)
	return os.WriteFile(outputPath, []byte(tsContent), 0644)
}

// Parses the Go files and returns the TypeScript type definitions
func (g *Generator) parseGoFiles() ([]*TypeDefinition, error) {
	var types []*TypeDefinition

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, g.InputDir, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file %s: %w", g.InputDir, err)
	}

	// Get package name
	packageName := node.Name.Name

	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		// Only process structs
		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// Only process exported types
		if !ast.IsExported(typeSpec.Name.Name) {
			return true
		}

		typeDef := g.parseStructType(typeSpec.Name.Name, structType)
		typeDef.Package = packageName
		types = append(types, typeDef)
		return true
	})

	return types, nil
}

// Parses the struct type and returns the TypeScript type definition
func (g *Generator) parseStructType(name string, structType *ast.StructType) *TypeDefinition {
	typeDef := &TypeDefinition{
		Name:       name,
		IsExported: ast.IsExported(name),
	}

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		prop := Property{
			Name:     field.Names[0].Name,
			Required: true,
			Tags:     g.parseStructTag(field.Tag.Value),
		}

		prop.Type = g.parseFieldType(field.Type)

		if field.Tag != nil {
			prop.Tags = g.parseStructTag(field.Tag.Value)
		}

		typeDef.Properties = append(typeDef.Properties, prop)
	}

	return typeDef
}

// Parses the field type and returns the TypeScript type
func (g *Generator) parseFieldType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return g.convertGoTypeToTS(t.Name)
	case *ast.ArrayType:
		elemType := g.parseFieldType(t.Elt)
		return fmt.Sprintf("Array<%s>", elemType)
	case *ast.MapType:
		keyType := g.parseFieldType(t.Key)
		valueType := g.parseFieldType(t.Value)
		return fmt.Sprintf("Record<%s, %s>", keyType, valueType)
	case *ast.StarExpr:
		return g.parseFieldType(t.X)
	case *ast.InterfaceType:
		return "any"
	case *ast.SelectorExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			if ident.Name == "time" && t.Sel.Name == "Time" {
				return "string" // time.Time as string
			}
		}
		return g.convertGoTypeToTS(t.Sel.Name)
	default:
		return "any"
	}
}

// Converts the Go type to the TypeScript type
func (g *Generator) convertGoTypeToTS(goType string) string {
	switch goType {
	case "string":
		return "string"
	case "int", "int8", "int16", "int32", "int64":
		return "number"
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "number"
	case "float32", "float64":
		return "number"
	case "bool":
		return "boolean"
	case "interface{}":
		return "any"
	default:
		return goType
	}
}

// Generates the TypeScript type definitions
func (g *Generator) generateTypeScript(types []*TypeDefinition) string {
	var sb strings.Builder

	sb.WriteString("// This file is automatically generated. DO NOT EDIT.\n\n")

	for _, t := range types {
		if !t.IsExported {
			continue
		}

		if g.Options.UseInterface {
			sb.WriteString(fmt.Sprintf("export interface %s {\n", t.Name))
		} else {
			sb.WriteString(fmt.Sprintf("export type %s = {\n", t.Name))
		}

		for _, prop := range t.Properties {
			if g.Options.UseReadonly {
				sb.WriteString("  readonly ")
			} else {
				sb.WriteString("  ")
			}

			name := prop.Name
			if jsonTag, ok := prop.Tags["json"]; ok {
				parts := strings.Split(jsonTag, ",")
				if len(parts) > 0 && parts[0] != "" {
					name = parts[0]
				}
			}
			name = g.convertName(name)

			sb.WriteString(fmt.Sprintf("%s: %s;\n", name, prop.Type))
		}

		sb.WriteString("}\n\n")
	}

	return sb.String()
}

// Parses the struct tag and returns the TypeScript type definition
func (g *Generator) parseStructTag(tag string) map[string]string {
	tags := make(map[string]string)
	tag = strings.Trim(tag, "`")

	for _, t := range strings.Split(tag, " ") {
		if t == "" {
			continue
		}

		parts := strings.SplitN(t, ":", 2)
		if len(parts) != 2 {
			continue
		}

		key := parts[0]
		value := strings.Trim(parts[1], "\"")
		tags[key] = value
	}

	return tags
}

// Converts the name to the specified naming convention
func (g *Generator) convertName(name string) string {
	switch g.Options.NamingConvention {
	case NamingConventionSnakeCase:
		return toSnakeCase(name)
	case NamingConventionCamelCase:
		return toCamelCase(name)
	default:
		return name
	}
}

// Converts the name to snake case
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result.WriteRune('_')
		}
		result.WriteRune(unicode.ToLower(r))
	}
	return result.String()
}

// Converts the name to camel case
func toCamelCase(s string) string {
	var result strings.Builder
	capitalize := false
	for i, r := range s {
		if i == 0 {
			result.WriteRune(unicode.ToLower(r))
			continue
		}
		if r == '_' {
			capitalize = true
			continue
		}
		if capitalize {
			result.WriteRune(unicode.ToUpper(r))
			capitalize = false
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}
