package typegen

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func NewGenerator(inputDir, outputDir string, opts *Options) *Generator {
	if opts == nil {
		opts = &Options{
			UseInterface:     false,
			UseReadonly:      false,
			OutputFileName:   "types.d.ts",
			NamingConvention: NamingConventionCamelCase,
		}
	}

	return &Generator{
		InputDir:  inputDir,
		OutputDir: outputDir,
		Options:   opts,
	}
}

func (g *Generator) Generate() error {
	types, err := g.parseGoFiles()
	if err != nil {
		return fmt.Errorf("failed to parse go files: %w", err)
	}

	tsContent := g.generateTypeScript(types)

	outputPath := filepath.Join(g.OutputDir, g.Options.OutputFileName)
	return os.WriteFile(outputPath, []byte(tsContent), 0644)
}

func (g *Generator) parseGoFiles() ([]*TypeDefinition, error) {
	var types []*TypeDefinition

	err := filepath.Walk(g.InputDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(path, ".go") {
			fset := token.NewFileSet()

			node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
			if err != nil {
				return fmt.Errorf("failed to parse file %s: %w", path, err)
			}

			ast.Inspect(node, func(n ast.Node) bool {
				typeSpec, ok := n.(*ast.TypeSpec)
				if !ok {
					return true
				}

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					return true
				}

				typeDef := g.parseStructType(typeSpec.Name.Name, structType)
				types = append(types, typeDef)
				return true
			})
		}
		return nil
	})

	return types, err
}

func (g *Generator) parseStructType(name string, structType *ast.StructType) *TypeDefinition {
	typeDef := &TypeDefinition{
		Name:       name,
		IsExported: ast.IsExported(name),
	}

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		prop := Property{
			Name:     field.Names[0].Name,
			Required: true,
			Tags:     g.parseStructTag(field.Tag.Value),
		}

		prop.Type = g.parseFieldType(field.Type)

		if field.Tag != nil {
			prop.Tags = g.parseStructTag(field.Tag.Value)
		}

		typeDef.Properties = append(typeDef.Properties, prop)
	}

	return typeDef
}

func (g *Generator) parseFieldType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return g.convertGoTypeToTS(t.Name)
	case *ast.ArrayType:
		elemType := g.parseFieldType(t.Elt)
		return fmt.Sprintf("Array<%s>", elemType)
	case *ast.MapType:
		keyType := g.parseFieldType(t.Key)
		valueType := g.parseFieldType(t.Value)
		return fmt.Sprintf("Record<%s, %s>", keyType, valueType)
	case *ast.StarExpr:
		return g.parseFieldType(t.X)
	default:
		return g.convertGoTypeToTS(fmt.Sprintf("%T", expr))
	}
}

func (g *Generator) convertGoTypeToTS(goType string) string {
	switch goType {
	case "string":
		return "string"
	case "int", "int8", "int16", "int32", "int64":
		return "number"
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "number"
	case "float32", "float64":
		return "number"
	case "bool":
		return "boolean"
	case "interface{}":
		return "any"
	default:
		return goType
	}
}

func (g *Generator) generateTypeScript(types []*TypeDefinition) string {
	var sb strings.Builder

	sb.WriteString("// This file is automatically generated. DO NOT EDIT.\n\n")

	for _, t := range types {
		if !t.IsExported {
			continue
		}

		if g.Options.UseInterface {
			sb.WriteString(fmt.Sprintf("export interface %s {\n", t.Name))
		} else {
			sb.WriteString(fmt.Sprintf("export type %s = {\n", t.Name))
		}

		for _, prop := range t.Properties {
			if g.Options.UseReadonly {
				sb.WriteString("  readonly ")
			} else {
				sb.WriteString("  ")
			}

			name := prop.Name
			if jsonTag, ok := prop.Tags["json"]; ok {
				parts := strings.Split(jsonTag, ",")
				if len(parts) > 0 && parts[0] != "" {
					name = parts[0]
				}
			}

			sb.WriteString(fmt.Sprintf("%s: %s;\n", name, prop.Type))
		}

		sb.WriteString("}\n\n")
	}

	return sb.String()
}

func (g *Generator) parseStructTag(tag string) map[string]string {
	tags := make(map[string]string)
	tag = strings.Trim(tag, "`")

	for _, t := range strings.Split(tag, " ") {
		if t == "" {
			continue
		}

		parts := strings.SplitN(t, ":", 2)
		if len(parts) != 2 {
			continue
		}

		key := parts[0]
		value := strings.Trim(parts[1], "\"")
		tags[key] = value
	}

	return tags
}
